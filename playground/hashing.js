const { SHA256 } = require("crypto-js");
const jwt = require("jsonwebtoken");

const bcrypt = require("bcryptjs");

var password = "123abc!";
// bcrypt.genSalt(10, (err, salt) => {
//   bcrypt.hash(password, salt, (e, hash) => {
//     console.log(hash);
//   });
// });

var hashedPassword =
  "$2a$10$Xma6Zxc3jTpl6uKe.3MKq..HQuHUwhoy8Ux/.iY.ocuFdTvPvm8nK";

bcrypt.compare(password, hashedPassword, (err, result) => {
  console.log(result);
});

// var data = {
//   id: 10
// };

// var salting_key = "123abc";

// var token_generated = jwt.sign(data, salting_key);
// console.log(token_generated);

// var decoded = jwt.verify(token_generated, salting_key);
// console.log("decoded: ", decoded);
// var data = {
//   id: 4
// };

// // Server sends this token to the user, which contains the data and hashed data with salting

// var token = {
//   data: data,
//   hash: SHA256(JSON.stringify(data) + "somesecret").toString()
// };

// // Now the user does not know the server's salting key, so even if the user changed the data and rehashed it,
// // he would not know the salting key, and thus the server's hash and user's hash could never match
// // This is how data is protected using tokens and SHA256 hashing

// // hash generated by hashing data recieved with salting key
// var resulthash = SHA256(JSON.stringify(token.data) + "somesecret").toString();

// if (resulthash === token.hash) {
//   console.log("Data was not changed");
// } else {
//   console.log("Data was tampered with");
// }
